import logging
import asyncio
from typing import Dict, List, Tuple
import bittensor as bt
from decimal import Decimal

from validator.services.price import PriceService
from validator.models.job import Job, MinerScore
from validator.repositories.job import JobRepository

logger = logging.getLogger(__name__)

class EmissionsService:
    """Service to calculate and set weights for miner emissions."""

    def __init__(self, metagraph: bt.Metagraph, subtensor: bt.Subtensor, job_repository: JobRepository):
        self.metagraph = metagraph
        self.subtensor = subtensor
        self.job_repository = job_repository

    async def get_vault_revenue_usd(self) -> float:
        """
        Get total revenue generated by vaults in USD.
        TODO: Implement real on-chain fetching of fees from Safe/Vaults.
        For now, returns a mock value or 0.
        """
        # Placeholder
        return 0.0

    async def calculate_emissions_split(self) -> Tuple[float, float]:
        """
        Calculate the split between Miner Burn (UID 0) and Active Miners.
        
        Returns:
            (burn_ratio, miner_ratio)
            e.g., (0.1, 0.9) means 10% burn, 90% to miners.
        """
        revenue_usd = await self.get_vault_revenue_usd()
        alpha_price_usd = await PriceService.get_alpha_price_usd()
        
        if alpha_price_usd <= 0:
            logger.warning("Alpha price is 0 or invalid, defaulting to 0% burn")
            return 0.0, 1.0

        # Calculate how much Alpha we want to burn
        burn_amount_alpha = revenue_usd / alpha_price_usd
        
        # Get total subnet emissions per epoch (in Tao/Alpha units)
        # metagraph.emission is in RAO per epoch? 
        # Actually metagraph.emission is a vector of emissions for the *last* epoch.
        # We assume next epoch is similar.
        # 1 Tao = 1e9 Rao.
        total_emission_rao = sum(self.metagraph.emission)
        total_emission_alpha = float(total_emission_rao) / 1e9
        
        if total_emission_alpha <= 0:
            logger.warning("Total emissions are 0, defaulting to 0% burn")
            return 0.0, 1.0

        # Calculate burn ratio
        burn_ratio = burn_amount_alpha / total_emission_alpha
        
        # Cap at 100%
        burn_ratio = min(max(burn_ratio, 0.0), 1.0)
        miner_ratio = 1.0 - burn_ratio
        
        logger.info(
            f"Emissions Split: Revenue=${revenue_usd:.2f}, Price=${alpha_price_usd:.2f}, "
            f"BurnTarget={burn_amount_alpha:.4f}, TotalEmission={total_emission_alpha:.4f}, "
            f"BurnRatio={burn_ratio:.4f}"
        )
        
        return burn_ratio, miner_ratio

    async def calculate_weights(self, miner_scores: Dict[int, float]) -> Tuple[List[int], List[float]]:
        """
        Calculate weights for all uids.
        
        Args:
            miner_scores: Dict mapping miner_uid -> score (0 to 1)
        
        Returns:
            (uids, weights)
        """
        uids = self.metagraph.uids.tolist()
        weights = [0.0] * len(uids)
        
        # 1. Calculate Burn Split
        burn_ratio, miner_ratio = await self.calculate_emissions_split()
        
        # 2. Assign Burn Weight to UID 0 (Owner)
        # Note: In Bittensor, dividends to the validator's own hotkey (UID 0 usually) 
        # are effectively burned/returned if not delegated? 
        # Actually, the user requirement is "assign weights to UID 0".
        # We assume UID 0 is the owner/validator and we want to direct emissions there to "burn".
        if 0 in uids:
            weights[0] = burn_ratio
        
        # 3. Distribute Miner Ratio among active miners based on scores
        total_score = sum(miner_scores.values())
        
        if total_score > 0 and miner_ratio > 0:
            for uid, score in miner_scores.items():
                if uid == 0:
                    continue # UID 0 is reserved for burn
                
                # Normalize score contribution
                normalized_score = score / total_score
                
                # Assign weight
                weights[uid] = normalized_score * miner_ratio
        
        return uids, weights

    async def get_miner_aggregate_scores(self) -> Dict[int, float]:
        """
        Calculate aggregate score for each miner across all jobs.
        Score = Sum(Job_Weight) for jobs where miner is winner.
        """
        winners = await self.job_repository.get_top_miners_by_job()
        scores = {}
        
        for job_id, miner_uid in winners.items():
            # TODO: Fetch real job weight (TVL/Fees)
            # For MVP, assuming equal weight per job
            job_weight = 1.0 
            
            scores[miner_uid] = scores.get(miner_uid, 0.0) + job_weight
            
        return scores

    async def set_weights_on_chain(self, wallet: bt.Wallet, netuid: int):
        """
        Calculate and set weights on chain.
        """
        logger.info("Starting weight setting process...")
        
        # 1. Get aggregate scores
        miner_scores = await self.get_miner_aggregate_scores()
        
        if not miner_scores:
            logger.warning("No miner scores found, skipping weight setting")
            return
            
        # 2. Calculate weights
        uids, weights = await self.calculate_weights(miner_scores)
        
        # 3. Set weights
        logger.info(f"Setting weights: {list(zip(uids, weights))}")
        
        try:
            success = self.subtensor.set_weights(
                netuid=netuid,
                wallet=wallet,
                uids=uids,
                weights=weights,
                wait_for_inclusion=False,
            )
            if success:
                logger.info("Successfully set weights")
            else:
                logger.error("Failed to set weights")
        except Exception as e:
            logger.error(f"Error setting weights: {e}")
