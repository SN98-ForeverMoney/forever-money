import logging
import asyncio
from typing import Dict, List, Tuple, Optional
import bittensor as bt
from decimal import Decimal

from validator.services.price import PriceService
from validator.services.revenue import RevenueService
from validator.models.job import Job, MinerScore
from validator.repositories.job import JobRepository
from validator.utils.env import NETUID, PROFIT_RATIO


logger = logging.getLogger(__name__)


class EmissionsService:
    """Service to calculate and set weights for miner emissions with Taoflow optimization."""

    def __init__(
        self,
        metagraph: bt.Metagraph,
        subtensor: bt.Subtensor,
        job_repository: JobRepository,
        revenue_service: Optional[RevenueService] = None,
        profit_ratio: Optional[float] = None,
    ):
        self.metagraph = metagraph
        self.subtensor = subtensor
        self.job_repository = job_repository
        self.revenue_service = revenue_service
        self.profit_ratio = (
            profit_ratio
            if profit_ratio is not None
            else PROFIT_RATIO
        )
        self.profit_ratio = max(0.0, min(1.0, float(self.profit_ratio)))

    async def get_vault_revenue_usd(self) -> float:
        """
        Get total revenue generated by vaults in USD.

        Returns:
            Total vault revenue in USD
        """
        if not self.revenue_service:
            logger.warning("RevenueService not available, returning 0 revenue")
            return 0.0

        try:
            revenue = await self.revenue_service.get_total_vault_revenue_usd(
                lookback_days=30
            )
            return revenue
        except Exception as e:
            logger.error(f"Failed to get vault revenue: {e}")
            return 0.0

    async def calculate_emissions_split(self) -> Tuple[float, float]:
        """
        Calculate the split between Miner Burn (UID 0) and Active Miners.

        Incentive-aligned logic: higher revenue → more to miners, less burn.

        - Unprofitable (revenue <= 0): 100% burn (all to UID 0)
        - Profitable (revenue > 0):
          - Revenue in Alpha = Vault Revenue (USD) / TWAP Alpha Price
          - Miner Ratio = min(profit_ratio, Revenue in Alpha / Total Subnet Emissions)
            → miners get a share that increases with revenue, capped at profit_ratio
            (profit_ratio is configurable via __init__ or PROFIT_RATIO env, default 1.0)
          - Burn Ratio = 1 - Miner Ratio
          - Miner Emissions = Total × Miner Ratio; Burn = Total × Burn Ratio

        Returns:
            (burn_ratio, miner_ratio)
            e.g., (0.1, 0.9) means 10% burn, 90% to miners.
        """
        revenue_usd = await self.get_vault_revenue_usd()
        alpha_price_usd = await PriceService.get_alpha_price_usd(
            self.subtensor, NETUID
        )

        # Total subnet emissions per epoch (in Alpha)
        total_emission_rao = sum(self.metagraph.emission)
        total_emission_alpha = float(total_emission_rao) / 1e9

        if total_emission_alpha <= 0:
            logger.warning("Total emissions are 0, defaulting to 100% burn")
            return 1.0, 0.0

        if revenue_usd <= 0:
            logger.info(
                "Unprofitable (revenue=%.2f): 100%% burn to UID 0",
                revenue_usd,
            )
            return 1.0, 0.0

        if alpha_price_usd <= 0:
            logger.warning(
                "Alpha price is 0 or invalid, defaulting to 0%% burn"
            )
            return 0.0, 1.0

        revenue_alpha = revenue_usd / alpha_price_usd

        # Miner share grows with revenue, capped at profit_ratio. Rest is burn.
        miner_ratio = min(
            self.profit_ratio,
            revenue_alpha / total_emission_alpha,
        )
        miner_ratio = max(0.0, miner_ratio)
        burn_ratio = 1.0 - miner_ratio

        miner_emissions_alpha = total_emission_alpha * miner_ratio
        burn_alpha = total_emission_alpha * burn_ratio

        logger.info(
            "Emissions split (revenue↑→miners↑): profit_ratio=%.2f "
            "revenue_usd=%.2f alpha_price=%.4f revenue_alpha=%.4f total=%.4f "
            "miner_ratio=%.4f burn_ratio=%.4f miner_alpha=%.4f burn_alpha=%.4f",
            self.profit_ratio,
            revenue_usd,
            alpha_price_usd,
            revenue_alpha,
            total_emission_alpha,
            miner_ratio,
            burn_ratio,
            miner_emissions_alpha,
            burn_alpha,
        )
        return burn_ratio, miner_ratio

    async def calculate_weights(self, miner_scores: Dict[int, float]) -> Tuple[List[int], List[float]]:
        """
        Calculate weights for all uids with Taoflow optimization.

        Logic:
        - Unprofitable: 100% to UID 0 (burn)
        - Profitable: miner_ratio grows with revenue (miners get more when
          revenue is higher); burn_ratio = 1 - miner_ratio. Rest to top miners.
        
        Args:
            miner_scores: Dict mapping miner_uid -> score (higher is better)
        
        Returns:
            (uids, weights) - Lists of UIDs and their corresponding weights
        """
        uids = self.metagraph.uids.tolist()
        weights = [0.0] * len(uids)
        
        # 1. Calculate Burn Split
        burn_ratio, miner_ratio = await self.calculate_emissions_split()
        
        # 2. Assign Burn Weight to UID 0
        # UID 0 receives burn_ratio proportion of total emissions
        uid_0_index = None
        for i, uid in enumerate(uids):
            if uid == 0:
                uid_0_index = i
                weights[i] = burn_ratio
                break
        
        if uid_0_index is None:
            logger.warning("UID 0 not found in metagraph, cannot assign burn weight")
        
        # 3. Distribute Miner Ratio among top miners based on scores
        if miner_ratio > 0 and miner_scores:
            # Sort miners by score (descending) to get top miners
            sorted_miners = sorted(
                miner_scores.items(), key=lambda x: x[1], reverse=True
            )
            
            # Calculate total score for normalization
            total_score = sum(score for uid, score in sorted_miners if uid != 0)
            
            if total_score > 0:
                # Distribute miner_ratio proportionally to top miners
                for uid, score in sorted_miners:
                    if uid == 0:
                        continue  # UID 0 is reserved for burn
                    
                    # Find UID index in metagraph
                    uid_index = None
                    for i, metagraph_uid in enumerate(uids):
                        if metagraph_uid == uid:
                            uid_index = i
                            break
                    
                    if uid_index is not None:
                        # Normalize score contribution
                        normalized_score = score / total_score
                        # Assign weight proportional to score
                        weights[uid_index] = normalized_score * miner_ratio
            else:
                logger.warning("Total miner score is 0, all miner emissions go to burn")
                # If no scores, add remaining ratio to burn
                if uid_0_index is not None:
                    weights[uid_0_index] = burn_ratio + miner_ratio
        elif miner_ratio > 0:
            logger.warning("No miner scores available, all emissions go to burn")
            # If no miners, add remaining ratio to burn
            if uid_0_index is not None:
                weights[uid_0_index] = burn_ratio + miner_ratio
        
        # Normalize weights to sum to 1.0 (Bittensor requirement)
        total_weight = sum(weights)
        if total_weight > 0:
            weights = [w / total_weight for w in weights]
        else:
            # Fallback: if all weights are 0, assign 100% to UID 0
            logger.warning("All weights are 0, defaulting to 100% burn")
            if uid_0_index is not None:
                weights[uid_0_index] = 1.0
        
        burn_weight = weights[uid_0_index] if uid_0_index is not None else 0.0
        miner_total = sum(
            w for i, w in enumerate(weights)
            if uid_0_index is None or i != uid_0_index
        )
        total_weight = sum(weights)
        
        logger.info(
            f"Weight distribution: Burn (UID 0)={burn_weight:.4f}, "
            f"Miner total={miner_total:.4f}, Total={total_weight:.4f}"
        )
        
        return uids, weights

    async def get_miner_aggregate_scores(self) -> Dict[int, float]:
        """
        Calculate aggregate score for each miner across all jobs.
        
        Uses combined_score from MinerScore model, which aggregates:
        - Performance scores from evaluation/live rounds
        - LP alignment scores
        
        Returns:
            Dict mapping miner_uid -> aggregate_score
        """
        try:
            # Get all active jobs
            active_jobs = await self.job_repository.get_active_jobs()
            if not active_jobs:
                logger.warning("No active jobs found for miner scoring")
                return {}

            scores = {}
            
            # Aggregate scores across all jobs
            for job in active_jobs:
                # Get top miners for this job (sorted by combined_score)
                miner_scores = await self.job_repository.get_eligible_miners(job.job_id)
                for miner_score in miner_scores:
                    uid = miner_score.miner_uid
                    combined_score = miner_score.combined_score

                    # Aggregate: sum of combined scores across all jobs
                    # Top miners will have higher aggregate scores
                    scores[uid] = scores.get(uid, 0.0) + float(combined_score)
            
            # Log top miners
            if scores:
                top_miners = sorted(scores.items(), key=lambda x: x[1], reverse=True)[:5]
                logger.info(f"Top 5 miners by aggregate score: {top_miners}")
            
            return scores
        except Exception as e:
            logger.error(f"Failed to get miner aggregate scores: {e}")
            return {}

    async def set_weights_on_chain(self, wallet: bt.Wallet, netuid: int):
        """
        Calculate and set weights on chain using Taoflow optimization.
        
        This method:
        1. Gets aggregate miner scores
        2. Calculates burn ratio based on vault revenue
        3. Distributes weights: burn to UID 0, rest to top miners
        4. Sets weights on-chain via subtensor
        """
        logger.info("=" * 60)
        logger.info("Starting weight setting process (Taoflow optimization)...")
        logger.info("=" * 60)
        
        # 1. Get aggregate scores
        miner_scores = await self.get_miner_aggregate_scores()
        
        # Even if no miner scores, we still want to set burn weights
        if not miner_scores:
            logger.warning("No miner scores found, will set 100% burn to UID 0")
            miner_scores = {}
            
        # 2. Calculate weights
        uids, weights = await self.calculate_weights(miner_scores)
        
        # Filter to only non-zero weights for logging (Bittensor accepts all UIDs)
        non_zero_weights = [
            (uid, weight) for uid, weight in zip(uids, weights) if weight > 0
        ]
        logger.info(f"Non-zero weights ({len(non_zero_weights)} UIDs): {non_zero_weights[:10]}...")  # Show first 10
        
        # 3. Set weights on-chain
        try:
            logger.info(f"Calling subtensor.set_weights for netuid={netuid}")
            success = self.subtensor.set_weights(
                netuid=netuid,
                wallet=wallet,
                uids=uids,
                weights=weights,
                wait_for_inclusion=False,
            )
            if success:
                logger.info("✓ Successfully set weights on-chain")
                logger.info(f"  Total UIDs: {len(uids)}")
                logger.info(f"  Non-zero weights: {len(non_zero_weights)}")
                burn_weight = next((w for uid, w in zip(uids, weights) if uid == 0), 0.0)
                logger.info(f"  Burn weight (UID 0): {burn_weight:.4f}")
            else:
                logger.error("✗ Failed to set weights (subtensor returned False)")
        except Exception as e:
            logger.error(f"✗ Error setting weights: {e}", exc_info=True)
