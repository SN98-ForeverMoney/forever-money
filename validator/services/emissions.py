import logging
import asyncio
from typing import Dict, List, Tuple, Optional
import bittensor as bt
from decimal import Decimal

from validator.services.price import PriceService
from validator.services.revenue import RevenueService
from validator.models.job import Job, MinerScore
from validator.repositories.job import JobRepository
from validator.utils.env import NETUID

logger = logging.getLogger(__name__)


class EmissionsService:
    """Service to calculate and set weights for miner emissions with Taoflow optimization."""

    def __init__(
        self,
        metagraph: bt.Metagraph,
        subtensor: bt.Subtensor,
        job_repository: JobRepository,
        revenue_service: Optional[RevenueService] = None,
    ):
        self.metagraph = metagraph
        self.subtensor = subtensor
        self.job_repository = job_repository
        self.revenue_service = revenue_service

    async def get_vault_revenue_usd(self) -> float:
        """
        Get total revenue generated by vaults in USD.

        Returns:
            Total vault revenue in USD
        """
        if not self.revenue_service:
            logger.warning("RevenueService not available, returning 0 revenue")
            return 0.0

        try:
            revenue = await self.revenue_service.get_total_vault_revenue_usd(
                lookback_days=30
            )
            return revenue
        except Exception as e:
            logger.error(f"Failed to get vault revenue: {e}")
            return 0.0

    async def calculate_emissions_split(self) -> Tuple[float, float]:
        """
        Calculate the split between Miner Burn (UID 0) and Active Miners.
        
        Logic:
        - Unprofitable (revenue <= 0): 100% burn (all to UID 0)
        - Profitable (revenue > 0): Partial burn
          - Burn Value = Vault Revenue (USD) / TWAP Alpha Price
          - Miner Emissions = Total Subnet Emissions - Burn Value
          - Assign weight to UID 0 proportional to Burn Value
        
        Returns:
            (burn_ratio, miner_ratio)
            e.g., (0.1, 0.9) means 10% burn, 90% to miners.
        """

        revenue_usd = await self.get_vault_revenue_usd()
        alpha_price_usd = await PriceService.get_alpha_price_usd(self.subtensor, NETUID)
        print(f"Alpha price usd: {alpha_price_usd}")
        
        # Get total subnet emissions per epoch (in Alpha units)
        # metagraph.emission is a vector of emissions for the *last* epoch in RAO
        # 1 Tao = 1e9 Rao, and Alpha ≈ Tao for subnet tokens
        total_emission_rao = sum(self.metagraph.emission)
        print(f"Total emission rao: {total_emission_rao}")
        total_emission_alpha = float(total_emission_rao) / 1e9

        total_emission_alpha = 10000
        revenue_usd = 2000
        
        if total_emission_alpha <= 0:
            logger.warning("Total emissions are 0, defaulting to 100% burn")
            return 1.0, 0.0

        # Unprofitable: 100% Miner Burn (All weights to UID 0)
        if revenue_usd <= 0:
            logger.info(
                f"Unprofitable (revenue=${revenue_usd:.2f}): 100% burn to UID 0"
            )
            return 1.0, 0.0

        # Profitable: Partial Burn
        if alpha_price_usd <= 0:
            logger.warning("Alpha price is 0 or invalid, defaulting to 0% burn")
            return 0.0, 1.0

        # Calculate Burn Value = Vault Revenue (USD) / TWAP Alpha Price
        burn_value_alpha = revenue_usd / alpha_price_usd
        
        # Miner Emissions = Total Subnet Emissions - Burn Value
        miner_emissions_alpha = max(0.0, total_emission_alpha - burn_value_alpha)
        
        # Calculate burn ratio
        burn_ratio = burn_value_alpha / total_emission_alpha
        
        # Cap at 100%
        burn_ratio = min(max(burn_ratio, 0.0), 1.0)
        miner_ratio = 1.0 - burn_ratio
        
        logger.info(
            f"Emissions Split (Profitable): Revenue=${revenue_usd:.2f}, "
            f"AlphaPrice=${alpha_price_usd:.2f}, "
            f"BurnValue={burn_value_alpha:.4f} Alpha, "
            f"TotalEmission={total_emission_alpha:.4f} Alpha, "
            f"MinerEmissions={miner_emissions_alpha:.4f} Alpha, "
            f"BurnRatio={burn_ratio:.4f}, MinerRatio={miner_ratio:.4f}"
        )
        
        return burn_ratio, miner_ratio

    async def calculate_weights(self, miner_scores: Dict[int, float]) -> Tuple[List[int], List[float]]:
        """
        Calculate weights for all uids with Taoflow optimization.
        
        Logic:
        - Unprofitable: 100% to UID 0 (burn)
        - Profitable: Partial burn to UID 0, rest distributed to top miners
        
        Args:
            miner_scores: Dict mapping miner_uid -> score (higher is better)
        
        Returns:
            (uids, weights) - Lists of UIDs and their corresponding weights
        """
        uids = self.metagraph.uids.tolist()
        weights = [0.0] * len(uids)
        
        # 1. Calculate Burn Split
        burn_ratio, miner_ratio = await self.calculate_emissions_split()
        
        # 2. Assign Burn Weight to UID 0
        # UID 0 receives burn_ratio proportion of total emissions
        uid_0_index = None
        for i, uid in enumerate(uids):
            if uid == 0:
                uid_0_index = i
                weights[i] = burn_ratio
                break
        
        if uid_0_index is None:
            logger.warning("UID 0 not found in metagraph, cannot assign burn weight")
        
        # 3. Distribute Miner Ratio among top miners based on scores
        if miner_ratio > 0 and miner_scores:
            # Sort miners by score (descending) to get top miners
            sorted_miners = sorted(
                miner_scores.items(), key=lambda x: x[1], reverse=True
            )
            
            # Calculate total score for normalization
            total_score = sum(score for uid, score in sorted_miners if uid != 0)
            
            if total_score > 0:
                # Distribute miner_ratio proportionally to top miners
                for uid, score in sorted_miners:
                    if uid == 0:
                        continue  # UID 0 is reserved for burn
                    
                    # Find UID index in metagraph
                    uid_index = None
                    for i, metagraph_uid in enumerate(uids):
                        if metagraph_uid == uid:
                            uid_index = i
                            break
                    
                    if uid_index is not None:
                        # Normalize score contribution
                        normalized_score = score / total_score
                        # Assign weight proportional to score
                        weights[uid_index] = normalized_score * miner_ratio
            else:
                logger.warning("Total miner score is 0, all miner emissions go to burn")
                # If no scores, add remaining ratio to burn
                if uid_0_index is not None:
                    weights[uid_0_index] = burn_ratio + miner_ratio
        elif miner_ratio > 0:
            logger.warning("No miner scores available, all emissions go to burn")
            # If no miners, add remaining ratio to burn
            if uid_0_index is not None:
                weights[uid_0_index] = burn_ratio + miner_ratio
        
        # Normalize weights to sum to 1.0 (Bittensor requirement)
        total_weight = sum(weights)
        if total_weight > 0:
            weights = [w / total_weight for w in weights]
        else:
            # Fallback: if all weights are 0, assign 100% to UID 0
            logger.warning("All weights are 0, defaulting to 100% burn")
            if uid_0_index is not None:
                weights[uid_0_index] = 1.0
        
        burn_weight = weights[uid_0_index] if uid_0_index is not None else 0.0
        miner_total = sum(
            w for i, w in enumerate(weights)
            if uid_0_index is None or i != uid_0_index
        )
        total_weight = sum(weights)
        
        logger.info(
            f"Weight distribution: Burn (UID 0)={burn_weight:.4f}, "
            f"Miner total={miner_total:.4f}, Total={total_weight:.4f}"
        )
        
        return uids, weights

    async def get_miner_aggregate_scores(self) -> Dict[int, float]:
        """
        Calculate aggregate score for each miner across all jobs.
        
        Uses combined_score from MinerScore model, which aggregates:
        - Performance scores from evaluation/live rounds
        - LP alignment scores
        
        Returns:
            Dict mapping miner_uid -> aggregate_score
        """
        try:
            # Get all active jobs
            active_jobs = await self.job_repository.get_active_jobs()
            if not active_jobs:
                logger.warning("No active jobs found for miner scoring")
                return {}

            scores = {}
            
            # Aggregate scores across all jobs
            for job in active_jobs:
                # Get top miners for this job (sorted by combined_score)
                miner_scores = await self.job_repository.get_eligible_miners(job.job_id)
                
                for miner_score in miner_scores:
                    uid = miner_score.miner_uid
                    combined_score = miner_score.combined_score

                    # Aggregate: sum of combined scores across all jobs
                    # Top miners will have higher aggregate scores
                    scores[uid] = scores.get(uid, 0.0) + float(combined_score)
            
            # Log top miners
            if scores:
                top_miners = sorted(scores.items(), key=lambda x: x[1], reverse=True)[:5]
                logger.info(f"Top 5 miners by aggregate score: {top_miners}")
            
            return scores
        except Exception as e:
            logger.error(f"Failed to get miner aggregate scores: {e}")
            return {}

    async def set_weights_on_chain(self, wallet: bt.Wallet, netuid: int):
        """
        Calculate and set weights on chain using Taoflow optimization.
        
        This method:
        1. Gets aggregate miner scores
        2. Calculates burn ratio based on vault revenue
        3. Distributes weights: burn to UID 0, rest to top miners
        4. Sets weights on-chain via subtensor
        """
        logger.info("=" * 60)
        logger.info("Starting weight setting process (Taoflow optimization)...")
        logger.info("=" * 60)
        
        # 1. Get aggregate scores
        miner_scores = await self.get_miner_aggregate_scores()
        
        # Even if no miner scores, we still want to set burn weights
        if not miner_scores:
            logger.warning("No miner scores found, will set 100% burn to UID 0")
            miner_scores = {}
            
        # 2. Calculate weights
        uids, weights = await self.calculate_weights(miner_scores)
        
        # Filter to only non-zero weights for logging (Bittensor accepts all UIDs)
        non_zero_weights = [
            (uid, weight) for uid, weight in zip(uids, weights) if weight > 0
        ]
        logger.info(f"Non-zero weights ({len(non_zero_weights)} UIDs): {non_zero_weights[:10]}...")  # Show first 10
        
        # 3. Set weights on-chain
        try:
            logger.info(f"Calling subtensor.set_weights for netuid={netuid}")
            success = self.subtensor.set_weights(
                netuid=netuid,
                wallet=wallet,
                uids=uids,
                weights=weights,
                wait_for_inclusion=False,
            )
            if success:
                logger.info("✓ Successfully set weights on-chain")
                logger.info(f"  Total UIDs: {len(uids)}")
                logger.info(f"  Non-zero weights: {len(non_zero_weights)}")
                burn_weight = next((w for uid, w in zip(uids, weights) if uid == 0), 0.0)
                logger.info(f"  Burn weight (UID 0): {burn_weight:.4f}")
            else:
                logger.error("✗ Failed to set weights (subtensor returned False)")
        except Exception as e:
            logger.error(f"✗ Error setting weights: {e}", exc_info=True)
