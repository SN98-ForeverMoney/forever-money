"""
Revenue Service for tracking vault fees and revenue.

Tracks accumulated fees from vaults (SNLiquidityManager contracts) by querying
CollectEvent data from the pool events database.
"""

import logging
from typing import Dict, List, Optional
from datetime import datetime, timedelta, timezone

from validator.models.job import Job
from validator.repositories.job import JobRepository
from validator.repositories.pool import PoolDataDB
from validator.services.price import PriceService

logger = logging.getLogger(__name__)


class RevenueService:
    """Service to track and calculate vault revenue in USD."""

    def __init__(
        self,
        job_repository: JobRepository,
        pool_data_db: Optional[PoolDataDB] = None,
    ):
        self.job_repository = job_repository
        self.pool_data_db = pool_data_db

    async def get_total_vault_revenue_usd(
        self,
        lookback_days: int = 30,
        pair_price_usd: Optional[float] = None,
    ) -> float:
        """
        Get total revenue generated by all active vaults in USD.

        Args:
            lookback_days: Number of days to look back for fee collection
            pair_price_usd: Optional price of token1/token0 pair in USD.
                          If None, will use PriceService to fetch.

        Returns:
            Total revenue in USD
        """
        if not self.pool_data_db:
            logger.warning("PoolDataDB not available, returning 0 revenue")
            return 0.0

        # Get all active jobs (vaults)
        active_jobs = await self.job_repository.get_active_jobs()
        if not active_jobs:
            logger.debug("No active jobs found, revenue is 0")
            return 0.0

        # Get vault addresses
        vault_addresses = [
            job.sn_liquidity_manager_address for job in active_jobs
        ]

        # Calculate time window
        end_time = datetime.now(timezone.utc)
        start_time = end_time - timedelta(days=lookback_days)

        # For now, we need block numbers. We'll approximate or fetch from a recent round
        # TODO: Add method to get block number from timestamp
        # For MVP, use a large range or fetch from recent rounds
        start_block = 0  # Will be filtered by time if available
        end_block = 999999999  # Large number

        # Get fees collected by all vaults
        try:
            vault_fees = await self.pool_data_db.get_miner_vault_fees(
                sn_liquditiy_manager_addresses=vault_addresses,
                start_block=start_block,
                end_block=end_block,
            )
        except Exception as e:
            logger.error(f"Failed to fetch vault fees: {e}")
            return 0.0

        # Convert fees to USD
        # We need token prices. For now, assume token0 and token1 prices
        # TODO: Fetch actual token prices from PriceService
        if pair_price_usd is None:
            # Try to get price from PriceService
            try:
                # This is a placeholder - in production, fetch actual token prices
                pair_price_usd = 1.0  # Default to 1:1 if unknown
            except Exception as e:
                logger.warning(f"Could not fetch pair price: {e}, using 1.0")
                pair_price_usd = 1.0

        # Fee amounts from DB are in wei (raw uint256). Convert to tokens (รท 1e18)
        # before applying USD prices. Same as get_vault_revenue_for_period.
        total_revenue_usd = 0.0
        for vault_addr, fees in vault_fees.items():
            fee0_wei = fees.get("fee0", 0.0)
            fee1_wei = fees.get("fee1", 0.0)
            fee0_tokens = float(fee0_wei) / 1e18
            fee1_tokens = float(fee1_wei) / 1e18

            # Convert to USD (simplified - token0 price = 1, token1 price = pair_price_usd)
            # In production, fetch actual token prices from PriceService
            revenue_usd = fee0_tokens * 1.0 + fee1_tokens * pair_price_usd
            total_revenue_usd += revenue_usd

            logger.debug(
                f"Vault {vault_addr}: fee0={fee0_tokens:.6f}, fee1={fee1_tokens:.6f}, "
                f"revenue_usd={revenue_usd:.2f}"
            )

        logger.info(
            f"Total vault revenue (last {lookback_days} days): ${total_revenue_usd:.2f}"
        )

        return total_revenue_usd

    async def get_vault_revenue_for_period(
        self,
        start_block: int,
        end_block: int,
        vault_addresses: Optional[List[str]] = None,
    ) -> float:
        """
        Get vault revenue for a specific block range.

        Args:
            start_block: Start block number
            end_block: End block number
            vault_addresses: Optional list of vault addresses to filter.
                           If None, uses all active jobs.

        Returns:
            Total revenue in USD (simplified calculation)
        """
        if not self.pool_data_db:
            return 0.0

        if vault_addresses is None:
            active_jobs = await self.job_repository.get_active_jobs()
            vault_addresses = [
                job.sn_liquidity_manager_address for job in active_jobs
            ]

        if not vault_addresses:
            return 0.0

        try:
            vault_fees = await self.pool_data_db.get_miner_vault_fees(
                sn_liquditiy_manager_addresses=vault_addresses,
                start_block=start_block,
                end_block=end_block,
            )
        except Exception as e:
            logger.error(f"Failed to fetch vault fees: {e}")
            return 0.0

        # Simplified USD conversion (assumes 1:1 price ratio)
        # TODO: Use actual token prices
        total_revenue_usd = 0.0
        for fees in vault_fees.values():
            fee0 = fees.get("fee0", 0.0)
            fee1 = fees.get("fee1", 0.0)
            # Convert from wei to tokens (assuming 18 decimals)
            fee0_tokens = fee0 / 1e18
            fee1_tokens = fee1 / 1e18
            # Simplified: assume both tokens worth $1 each
            total_revenue_usd += fee0_tokens + fee1_tokens

        return total_revenue_usd