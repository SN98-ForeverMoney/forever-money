"""
Revenue Service for tracking vault fees and revenue.

Tracks accumulated fees from vaults (SNLiquidityManager contracts) by querying
CollectEvent data from the pool events database.
"""

import sys
import os

# Setup path for running as script - must be before any validator imports
# Check if validator module is importable, if not, add project root to path
try:
    import validator
except ImportError:
    # Add project root to path BEFORE any validator imports
    script_dir = os.path.dirname(os.path.abspath(__file__))
    project_root = os.path.abspath(os.path.join(script_dir, "..", ".."))
    if project_root not in sys.path:
        sys.path.insert(0, project_root)
    os.chdir(project_root)

import asyncio
import logging
from datetime import datetime, timedelta, timezone
from typing import Dict, List, Optional, Tuple

from validator.repositories.job import JobRepository
from validator.repositories.pool import PoolDataDB
from validator.services.price import PriceService
from validator.utils.web3 import AsyncWeb3Helper

logger = logging.getLogger(__name__)


def _normalize_address(addr: str) -> str:
    """Return lowercase address with 0x prefix."""
    s = (addr or "").strip().lower()
    return s if s.startswith("0x") else "0x" + s


async def _resolve_pool_tokens(
    chain_id: int, pair_address: str
) -> Optional[Tuple[str, str]]:
    """Resolve token0 and token1 addresses from a pool contract. Returns None on failure."""
    try:
        w3 = AsyncWeb3Helper.make_web3(chain_id)
        pool = w3.make_contract_by_name("ICLPool", _normalize_address(pair_address))
        token0, token1 = await asyncio.gather(
            pool.functions.token0().call(),
            pool.functions.token1().call(),
        )
        return (token0, token1)
    except Exception as e:
        logger.warning(
            f"Could not resolve pool tokens for pair={pair_address} chain_id={chain_id}: {e}"
        )
        return None


class RevenueService:
    """Service to track and calculate vault revenue in USD."""

    def __init__(
        self,
        job_repository: JobRepository,
        pool_data_db: Optional[PoolDataDB] = None,
    ):
        self.job_repository = job_repository
        self.pool_data_db = pool_data_db

    async def get_total_vault_revenue_usd(
        self,
        lookback_days: int = 30,
        pair_price_usd: Optional[float] = None,
    ) -> float:
        """
        Get total revenue generated by all active vaults in USD.

        Uses PriceService.get_token_price (CoinGecko) to convert fee0/fee1 to USD.
        Resolves token0/token1 per pool via chain + pair_address.

        Args:
            lookback_days: Number of days to look back for fee collection.
            pair_price_usd: Deprecated. If provided, overrides token1 price only
                (token0 still uses get_token_price). Prefer None to use full API pricing.

        Returns:
            Total revenue in USD.
        """
        if not self.pool_data_db:
            logger.warning("PoolDataDB not available, returning 0 revenue")
            return 0.0

        active_jobs = await self.job_repository.get_active_jobs()
        if not active_jobs:
            logger.debug("No active jobs found, revenue is 0")
            return 0.0

        vault_addresses = [j.sn_liquidity_manager_address for j in active_jobs]
        start_block = 0
        end_block = 999999999

        try:
            vault_fees = await self.pool_data_db.get_miner_vault_fees(
                sn_liquditiy_manager_addresses=vault_addresses,
                start_block=start_block,
                end_block=end_block,
            )
        except Exception as e:
            logger.error(f"Failed to fetch vault fees: {e}")
            return 0.0

        def _vault_key(a: str) -> str:
            return _normalize_address(a).replace("0x", "")

        vault_to_pool: Dict[str, Tuple[str, int]] = {}
        for j in active_jobs:
            k = _vault_key(j.sn_liquidity_manager_address)
            pair_norm = _normalize_address(j.pair_address)
            vault_to_pool[k] = (pair_norm, j.chain_id)

        seen_pools: Dict[Tuple[str, int], Tuple[str, str]] = {}
        for (pair, cid) in set(vault_to_pool.values()):
            tok = await _resolve_pool_tokens(cid, pair)
            if tok:
                seen_pools[(pair, cid)] = tok

        token_prices: Dict[Tuple[str, int], float] = {}
        for (pair, cid), (t0, t1) in seen_pools.items():
            for addr in (t0, t1):
                key = (addr, cid)
                if key not in token_prices:
                    token_prices[key] = await PriceService.get_token_price(
                        addr, cid
                    )

        total_revenue_usd = 0.0
        for vault_addr, fees in vault_fees.items():
            vk = _vault_key(vault_addr)
            pool_info = vault_to_pool.get(vk)
            if not pool_info:
                continue
            pair_addr, chain_id = pool_info
            tokens = seen_pools.get((pair_addr, chain_id))
            if not tokens:
                continue
            token0_addr, token1_addr = tokens
            p0 = token_prices.get((token0_addr, chain_id), 1.0)
            p1 = token_prices.get((token1_addr, chain_id), 1.0)
            if pair_price_usd is not None:
                p1 = pair_price_usd

            fee0_wei = fees.get("fee0", 0.0)
            fee1_wei = fees.get("fee1", 0.0)
            fee0_tokens = float(fee0_wei) / 1e18
            fee1_tokens = float(fee1_wei) / 1e18
            revenue_usd = fee0_tokens * p0 + fee1_tokens * p1
            total_revenue_usd += revenue_usd
            logger.debug(
                f"Vault {vault_addr}: fee0={fee0_tokens:.6f} fee1={fee1_tokens:.6f} "
                f"revenue_usd={revenue_usd:.2f}"
            )

        logger.info(
            f"Total vault revenue (last {lookback_days} days): ${total_revenue_usd:.2f}"
        )
        return total_revenue_usd

    async def get_vault_revenue_for_period(
        self,
        start_block: int,
        end_block: int,
        vault_addresses: Optional[List[str]] = None,
    ) -> float:
        """
        Get vault revenue for a specific block range in USD.

        Uses PriceService.get_token_price (CoinGecko) to convert fee0/fee1 to USD.
        Vaults must belong to active jobs so we can resolve pool tokens.

        Args:
            start_block: Start block number.
            end_block: End block number.
            vault_addresses: Optional list of vault addresses to filter.
                If None, uses all active jobs.

        Returns:
            Total revenue in USD.
        """
        if not self.pool_data_db:
            return 0.0

        active_jobs = await self.job_repository.get_active_jobs()
        if vault_addresses is None:
            vault_addresses = [
                j.sn_liquidity_manager_address for j in active_jobs
            ]
        if not vault_addresses:
            return 0.0

        try:
            vault_fees = await self.pool_data_db.get_miner_vault_fees(
                sn_liquditiy_manager_addresses=vault_addresses,
                start_block=start_block,
                end_block=end_block,
            )
        except Exception as e:
            logger.error(f"Failed to fetch vault fees: {e}")
            return 0.0

        def _vault_key(a: str) -> str:
            return _normalize_address(a).replace("0x", "")

        allowed = {_vault_key(v) for v in vault_addresses}
        vault_to_pool: Dict[str, Tuple[str, int]] = {}
        for j in active_jobs:
            k = _vault_key(j.sn_liquidity_manager_address)
            if k not in allowed:
                continue
            pair_norm = _normalize_address(j.pair_address)
            vault_to_pool[k] = (pair_norm, j.chain_id)

        seen_pools: Dict[Tuple[str, int], Tuple[str, str]] = {}
        for (pair, cid) in set(vault_to_pool.values()):
            tok = await _resolve_pool_tokens(cid, pair)
            if tok:
                seen_pools[(pair, cid)] = tok

        token_prices: Dict[Tuple[str, int], float] = {}
        for (pair, cid), (t0, t1) in seen_pools.items():
            for addr in (t0, t1):
                key = (addr, cid)
                if key not in token_prices:
                    token_prices[key] = await PriceService.get_token_price(
                        addr, cid
                    )

        total_revenue_usd = 0.0
        for vault_addr, fees in vault_fees.items():
            vk = _vault_key(vault_addr)
            pool_info = vault_to_pool.get(vk)
            if not pool_info:
                continue
            pair_addr, chain_id = pool_info
            tokens = seen_pools.get((pair_addr, chain_id))
            if not tokens:
                continue
            t0_addr, t1_addr = tokens
            p0 = token_prices.get((t0_addr, chain_id), 1.0)
            p1 = token_prices.get((t1_addr, chain_id), 1.0)

            fee0 = float(fees.get("fee0", 0.0))
            fee1 = float(fees.get("fee1", 0.0))
            fee0_tokens = fee0 / 1e18
            fee1_tokens = fee1 / 1e18
            total_revenue_usd += fee0_tokens * p0 + fee1_tokens * p1

        return total_revenue_usd


# Test runner
if __name__ == "__main__":
    import asyncio
    
    # Imports (path already set up at top of file)
    from validator.repositories.job import JobRepository
    from validator.repositories.pool import PoolDataDB, init_pool_events_db
    from validator.models.job import init_db, close_db
    from validator.utils.env import (
        JOBS_POSTGRES_HOST,
        JOBS_POSTGRES_PORT,
        JOBS_POSTGRES_DB,
        JOBS_POSTGRES_USER,
        JOBS_POSTGRES_PASSWORD,
    )
    
    # Setup logging
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    )
    
    async def test_revenue_service():
        """Test RevenueService functionality."""
        print("=" * 60)
        print("Testing RevenueService")
        print("=" * 60)
        
        # Initialize database
        db_url = (
            f"postgres://{JOBS_POSTGRES_USER}:{JOBS_POSTGRES_PASSWORD}@"
            f"{JOBS_POSTGRES_HOST}:{JOBS_POSTGRES_PORT}/{JOBS_POSTGRES_DB}"
        )
        
        try:
            print("\n1. Initializing database connection...")
            await init_db(db_url)
            print("   ✓ Database connected")
            
            # Initialize JobRepository
            print("\n2. Initializing JobRepository...")
            job_repo = JobRepository()
            print("   ✓ JobRepository initialized")
            
            # Try to initialize PoolDataDB (optional)
            pool_data_db = None
            # pool_events_db_url = os.getenv("POOL_EVENTS_DB_URL")
            pool_events_db_url = db_url

            if pool_events_db_url:
                try:
                    print("\n3. Initializing PoolDataDB...")
                    await init_pool_events_db(pool_events_db_url)
                    pool_data_db = PoolDataDB()
                    print("   ✓ PoolDataDB initialized")
                except Exception as e:
                    print(f"   ⚠ PoolDataDB not available: {e}")
                    print("   (RevenueService will work but return 0 revenue)")
            else:
                print("\n3. PoolDataDB not configured (POOL_EVENTS_DB_URL not set)")
                print("   (RevenueService will work but return 0 revenue)")
            
            # Initialize RevenueService
            print("\n4. Initializing RevenueService...")
            revenue_service = RevenueService(
                job_repository=job_repo,
                pool_data_db=pool_data_db,
            )
            print("   ✓ RevenueService initialized")
            
            # Test get_total_vault_revenue_usd
            print("\n5. Testing get_total_vault_revenue_usd()...")
            total_revenue = await revenue_service.get_total_vault_revenue_usd(lookback_days=30)
            print(f"   Total Vault Revenue (30 days): ${total_revenue:.2f} USD")
            
            # Test get_vault_revenue_for_period
            print("\n6. Testing get_vault_revenue_for_period()...")
            period_revenue = await revenue_service.get_vault_revenue_for_period(
                start_block=0,
                end_block=999999999,
            )
            print(f"   Period Revenue: ${period_revenue:.2f} USD")
            
            print("\n" + "=" * 60)
            print("RevenueService test completed!")
            print("=" * 60)
            
        except Exception as e:
            print(f"\n✗ Error during test: {e}")
            import traceback
            traceback.print_exc()
        finally:
            # Cleanup
            try:
                await close_db()
            except:
                pass
    
    # Run test
    asyncio.run(test_revenue_service())