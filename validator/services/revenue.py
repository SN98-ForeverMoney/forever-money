"""
Revenue Service for tracking vault fees and revenue.

Tracks accumulated fees from vaults (SNLiquidityManager contracts) by querying
CollectEvent data from the pool events database.
"""
import asyncio
import logging
from typing import Dict, List, Optional, Tuple

from validator.repositories.job import JobRepository
from validator.repositories.pool import PoolDataDB
from validator.services.price import PriceService
from validator.utils.web3 import AsyncWeb3Helper

logger = logging.getLogger(__name__)

# Approximate blocks per day by chain (for lookback_days -> block range conversion)
# Chain IDs: 1=Ethereum, 8453=Base, 137=Polygon, 42161=Arbitrum, 10=Optimism, etc.
CHAIN_BLOCKS_PER_DAY: Dict[int, int] = {
    1: 7200,       # Ethereum ~12s/block
    8453: 43200,   # Base ~2s/block
    137: 43200,    # Polygon ~2s/block
    42161: 172800, # Arbitrum ~0.5s/block
    10: 43200,     # Optimism ~2s/block
    43114: 28800,  # Avalanche ~3s/block
    56: 28800,     # BSC ~3s/block
}
DEFAULT_BLOCKS_PER_DAY = 43200  # fallback for unknown chains


def _normalize_address(addr: str) -> str:
    """Return lowercase address with 0x prefix."""
    s = (addr or "").strip().lower()
    return s if s.startswith("0x") else "0x" + s


async def _get_block_range_for_lookback(
    chain_id: int, lookback_days: int
) -> Tuple[int, int]:
    """
    Get (start_block, end_block) for a lookback period.

    Uses current block from chain and approximate blocks per day.
    """
    w3 = AsyncWeb3Helper.make_web3(chain_id)
    end_block = await w3.web3.eth.block_number
    blocks_per_day = CHAIN_BLOCKS_PER_DAY.get(
        chain_id, DEFAULT_BLOCKS_PER_DAY
    )
    blocks_in_period = lookback_days * blocks_per_day
    start_block = max(0, end_block - blocks_in_period)
    return start_block, end_block


async def _resolve_pool_tokens(
    chain_id: int, pair_address: str
) -> Optional[Tuple[str, str]]:
    """Resolve token0 and token1 addresses from a pool contract. Returns None on failure."""
    try:
        w3 = AsyncWeb3Helper.make_web3(chain_id)
        pool = w3.make_contract_by_name("ICLPool", _normalize_address(pair_address))
        token0, token1 = await asyncio.gather(
            pool.functions.token0().call(),
            pool.functions.token1().call(),
        )
        return (token0, token1)
    except Exception as e:
        logger.warning(
            f"Could not resolve pool tokens for pair={pair_address} chain_id={chain_id}: {e}"
        )
        return None


class RevenueService:
    """Service to track and calculate vault revenue in USD."""

    def __init__(
        self,
        job_repository: JobRepository,
        pool_data_db: Optional[PoolDataDB] = None,
    ):
        self.job_repository = job_repository
        self.pool_data_db = pool_data_db

    async def get_total_vault_revenue_usd(
        self,
        lookback_days: int = 30,
        pair_price_usd: Optional[float] = None,
    ) -> float:
        """
        Get total revenue generated by all active vaults in USD.

        Uses PriceService.get_token_price (CoinGecko) to convert fee0/fee1 to USD.
        Resolves token0/token1 per pool via chain + pair_address.

        Args:
            lookback_days: Number of days to look back for fee collection.
            pair_price_usd: Deprecated. If provided, overrides token1 price only
                (token0 still uses get_token_price). Prefer None to use full API pricing.

        Returns:
            Total revenue in USD.
        """
        if not self.pool_data_db:
            logger.warning("PoolDataDB not available, returning 0 revenue")
            return 0.0

        active_jobs = await self.job_repository.get_active_jobs()
        if not active_jobs:
            logger.debug("No active jobs found, revenue is 0")
            return 0.0

        vault_addresses = [j.sn_liquidity_manager_address for j in active_jobs]
        # Use chain from first job; pool_events DB typically indexes one chain
        chain_id = active_jobs[0].chain_id
        start_block, end_block = await _get_block_range_for_lookback(
            chain_id, lookback_days
        )

        try:
            vault_fees = await self.pool_data_db.get_miner_vault_fees(
                sn_liquidity_manager_addresses=vault_addresses,
                start_block=start_block,
                end_block=end_block,
            )
        except Exception as e:
            logger.error(f"Failed to fetch vault fees: {e}")
            return 0.0

        def _vault_key(a: str) -> str:
            return _normalize_address(a).replace("0x", "")

        vault_to_pool: Dict[str, Tuple[str, int]] = {}
        for j in active_jobs:
            k = _vault_key(j.sn_liquidity_manager_address)
            pair_norm = _normalize_address(j.pair_address)
            vault_to_pool[k] = (pair_norm, j.chain_id)

        seen_pools: Dict[Tuple[str, int], Tuple[str, str]] = {}
        for (pair, cid) in set(vault_to_pool.values()):
            tok = await _resolve_pool_tokens(cid, pair)
            if tok:
                seen_pools[(pair, cid)] = tok

        token_prices: Dict[Tuple[str, int], float] = {}
        for (pair, cid), (t0, t1) in seen_pools.items():
            for addr in (t0, t1):
                key = (addr, cid)
                if key not in token_prices:
                    token_prices[key] = await PriceService.get_token_price(
                        addr, cid
                    )

        total_revenue_usd = 0.0
        for vault_addr, fees in vault_fees.items():
            vk = _vault_key(vault_addr)
            pool_info = vault_to_pool.get(vk)
            if not pool_info:
                continue
            pair_addr, chain_id = pool_info
            tokens = seen_pools.get((pair_addr, chain_id))
            if not tokens:
                continue
            token0_addr, token1_addr = tokens
            p0 = token_prices.get((token0_addr, chain_id), 1.0)
            p1 = token_prices.get((token1_addr, chain_id), 1.0)
            if pair_price_usd is not None:
                p1 = pair_price_usd

            fee0_wei = fees.get("fee0", 0.0)
            fee1_wei = fees.get("fee1", 0.0)
            fee0_tokens = float(fee0_wei) / 1e18
            fee1_tokens = float(fee1_wei) / 1e18
            revenue_usd = fee0_tokens * p0 + fee1_tokens * p1
            total_revenue_usd += revenue_usd
            logger.debug(
                f"Vault {vault_addr}: fee0={fee0_tokens:.6f} fee1={fee1_tokens:.6f} "
                f"revenue_usd={revenue_usd:.2f}"
            )

        logger.info(
            f"Total vault revenue (last {lookback_days} days): ${total_revenue_usd:.2f}"
        )
        return total_revenue_usd

    async def get_vault_revenue_for_period(
        self,
        start_block: int,
        end_block: int,
        vault_addresses: Optional[List[str]] = None,
    ) -> float:
        """
        Get vault revenue for a specific block range in USD.

        Uses PriceService.get_token_price (CoinGecko) to convert fee0/fee1 to USD.
        Vaults must belong to active jobs so we can resolve pool tokens.

        Args:
            start_block: Start block number.
            end_block: End block number.
            vault_addresses: Optional list of vault addresses to filter.
                If None, uses all active jobs.

        Returns:
            Total revenue in USD.
        """
        if not self.pool_data_db:
            return 0.0

        active_jobs = await self.job_repository.get_active_jobs()
        if vault_addresses is None:
            vault_addresses = [
                j.sn_liquidity_manager_address for j in active_jobs
            ]
        if not vault_addresses:
            return 0.0

        try:
            vault_fees = await self.pool_data_db.get_miner_vault_fees(
                sn_liquidity_manager_addresses=vault_addresses,
                start_block=start_block,
                end_block=end_block,
            )
        except Exception as e:
            logger.error(f"Failed to fetch vault fees: {e}")
            return 0.0

        def _vault_key(a: str) -> str:
            return _normalize_address(a).replace("0x", "")

        allowed = {_vault_key(v) for v in vault_addresses}
        vault_to_pool: Dict[str, Tuple[str, int]] = {}
        for j in active_jobs:
            k = _vault_key(j.sn_liquidity_manager_address)
            if k not in allowed:
                continue
            pair_norm = _normalize_address(j.pair_address)
            vault_to_pool[k] = (pair_norm, j.chain_id)

        seen_pools: Dict[Tuple[str, int], Tuple[str, str]] = {}
        for (pair, cid) in set(vault_to_pool.values()):
            tok = await _resolve_pool_tokens(cid, pair)
            if tok:
                seen_pools[(pair, cid)] = tok

        token_prices: Dict[Tuple[str, int], float] = {}
        for (pair, cid), (t0, t1) in seen_pools.items():
            for addr in (t0, t1):
                key = (addr, cid)
                if key not in token_prices:
                    token_prices[key] = await PriceService.get_token_price(
                        addr, cid
                    )

        total_revenue_usd = 0.0
        for vault_addr, fees in vault_fees.items():
            vk = _vault_key(vault_addr)
            pool_info = vault_to_pool.get(vk)
            if not pool_info:
                continue
            pair_addr, chain_id = pool_info
            tokens = seen_pools.get((pair_addr, chain_id))
            if not tokens:
                continue
            t0_addr, t1_addr = tokens
            p0 = token_prices.get((t0_addr, chain_id), 1.0)
            p1 = token_prices.get((t1_addr, chain_id), 1.0)

            fee0 = float(fees.get("fee0", 0.0))
            fee1 = float(fees.get("fee1", 0.0))
            fee0_tokens = fee0 / 1e18
            fee1_tokens = fee1 / 1e18
            total_revenue_usd += fee0_tokens * p0 + fee1_tokens * p1

        return total_revenue_usd
